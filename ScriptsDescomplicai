-- ==============================================
-- TABELAS
-- ==============================================

-- USER
CREATE TABLE IF NOT EXISTS descomplicai.user(
  id SERIAL PRIMARY KEY,
  name_user VARCHAR(100) NOT NULL,
  email VARCHAR(100),
  password_user VARCHAR(60) NOT NULL,
  creation_data TIMESTAMP DEFAULT now(),
  profile_image VARCHAR(200),
  type_user  VARCHAR(100),
  status VARCHAR(100),
  phone VARCHAR(14),
  temp_login_token VARCHAR(170),
  temp_login_expire DATE
);

-- ADDRESS
CREATE TABLE IF NOT EXISTS descomplicai.address(
  id SERIAL PRIMARY KEY,
  street VARCHAR(150) NOT NULL,
  cep VARCHAR(8) NOT NULL,
  number_address VARCHAR(10) NOT NULL,
  neighborhood VARCHAR(60) NOT NULL,
  complement VARCHAR(100),
  reference  VARCHAR(200),
  city VARCHAR(100) NOT NULL,
  uf VARCHAR(2)
);

-- USER_ADDRESS
CREATE TABLE IF NOT EXISTS descomplicai.user_address(
    user_id INTEGER NOT NULL,
    address_id INTEGER NOT NULL,
    type_address VARCHAR(30) NOT NULL CHECK(type_address in ('entrega', 'cobranca')),
    CONSTRAINT pk_user_address PRIMARY KEY (user_id, address_id),
    CONSTRAINT fk_user_address_user FOREIGN KEY (user_id)
        REFERENCES descomplicai.user(id),
    CONSTRAINT fk_user_address_address FOREIGN KEY (address_id)
        REFERENCES descomplicai.address(id)
);

-- CATEGORY
CREATE TABLE IF NOT EXISTS descomplicai.category(
    id SERIAL PRIMARY KEY,
    name_category VARCHAR(100) NOT NULL,
    description VARCHAR(200),
    image VARCHAR(200),
    status VARCHAR(200)
);

-- PRODUCT (ADDED category_id)
CREATE TABLE IF NOT EXISTS descomplicai.product(
    id SERIAL PRIMARY KEY,
    name_product VARCHAR(100) NOT NULL,
    description VARCHAR(300),
    price NUMERIC(10,2) NOT NULL,
    availability BOOLEAN,
    image VARCHAR(200),
    extras VARCHAR(200),
    category_id INTEGER, -- Added this column for primary category
    CONSTRAINT fk_product_category FOREIGN KEY (category_id)
        REFERENCES descomplicai.category(id)
);

-- INVENTORY
CREATE TABLE IF NOT EXISTS descomplicai.inventory(
    id SERIAL PRIMARY KEY,
    amount INTEGER,
    amount_min INTEGER,
    last_update TIMESTAMP DEFAULT now(),
    status VARCHAR(100),
    product_id INTEGER UNIQUE, -- Product ID should be unique in inventory
    CONSTRAINT fk_inventory_product FOREIGN KEY (product_id)
        REFERENCES descomplicai.product(id)
);

-- PRODUCT_CATEGORIES (For secondary categories if needed)
CREATE TABLE IF NOT EXISTS descomplicai.product_categories(
    product_id INTEGER NOT NULL,
    category_id INTEGER NOT NULL,
    CONSTRAINT pk_product_categories PRIMARY KEY (product_id, category_id),
    CONSTRAINT fk_product_categories_product FOREIGN KEY (product_id)
        REFERENCES descomplicai.product(id),
    CONSTRAINT fk_product_categories_category FOREIGN KEY (category_id)
        REFERENCES descomplicai.category(id)
);

-- ORDER
CREATE TABLE IF NOT EXISTS descomplicai.order(
    id SERIAL PRIMARY KEY,
    order_date TIMESTAMP DEFAULT now(),
    status VARCHAR(100),
    delivery_tax NUMERIC(10,2),
    payment_method VARCHAR(100),
    user_id INTEGER,
    total_value NUMERIC(10,2),
    CONSTRAINT fk_order_user FOREIGN KEY (user_id)
      REFERENCES descomplicai.user(id)
);

-- ORDER_ADDRESS
CREATE TABLE IF NOT EXISTS descomplicai.order_address(
  order_id INTEGER NOT NULL,
  street VARCHAR(150) NOT NULL,
  type_address VARCHAR(30),
  cep VARCHAR(8) NOT NULL,
  number_address VARCHAR(10) NOT NULL,
  neighborhood VARCHAR(60) NOT NULL,
  complement VARCHAR(100),
  reference  VARCHAR(200),
  city VARCHAR(100) NOT NULL,
  uf VARCHAR(2),
  CONSTRAINT pk_order_address PRIMARY KEY (order_id),
  CONSTRAINT fk_order_address_order FOREIGN KEY (order_id)
      REFERENCES descomplicai.order(id)
);

-- PRODUCT_ORDER (Composite PK)
CREATE TABLE IF NOT EXISTS descomplicai.product_order(
  product_id INTEGER NOT NULL,
  order_id INTEGER NOT NULL,
  amount INTEGER NOT NULL,
  total_value NUMERIC(10,2),
  CONSTRAINT pk_product_order PRIMARY KEY (order_id, product_id),
  CONSTRAINT fk_product_order_product FOREIGN KEY (product_id)
      REFERENCES descomplicai.product(id),
  CONSTRAINT fk_product_order_order FOREIGN KEY (order_id)
      REFERENCES descomplicai.order(id)
);

-- ORDER_HIST
CREATE TABLE IF NOT EXISTS descomplicai.order_hist(
  idlog SERIAL PRIMARY KEY,
  order_id INTEGER,
  status VARCHAR(100),
  order_date TIMESTAMP, -- This should be the original order date
  delivery_tax NUMERIC(10,2),
  payment_method VARCHAR(100),
  user_id INTEGER,
  total_value NUMERIC(10,2),
  date_alter TIMESTAMP DEFAULT NOW(),
  CONSTRAINT fk_order_hist_order FOREIGN KEY (order_id)
    REFERENCES descomplicai.order(id),
  CONSTRAINT fk_order_hist_user FOREIGN KEY (user_id)
    REFERENCES descomplicai.user(id)
);

-- PROMOTION
CREATE TABLE IF NOT EXISTS descomplicai.promotion(
  id SERIAL PRIMARY KEY,
  name_promotion VARCHAR(100) NOT NULL,
  type_promotion VARCHAR(100) NOT NULL,
  value NUMERIC(10,2),
  start_date DATE,
  end_date DATE,
  active BOOLEAN,
  priority INTEGER DEFAULT 0 -- Added priority for selecting promotions
);

-- PROMOTION_PRODUCTS
CREATE TABLE IF NOT EXISTS descomplicai.promotion_products(
  product_id INTEGER,
  promotion_id INTEGER,
  CONSTRAINT pk_promotion_products PRIMARY KEY (product_id, promotion_id),
  CONSTRAINT fk_promotion_products_product FOREIGN KEY (product_id)
    REFERENCES descomplicai.product(id),
  CONSTRAINT fk_promotion_products_promotion FOREIGN KEY (promotion_id)
    REFERENCES descomplicai.promotion(id)
);

-- PROMOTION_CATEGORIES
CREATE TABLE IF NOT EXISTS descomplicai.promotion_categories(
  category_id INTEGER,
  promotion_id INTEGER,
  CONSTRAINT pk_promotion_categories PRIMARY KEY (category_id, promotion_id),
  CONSTRAINT fk_promotion_categories_category FOREIGN KEY (category_id)
    REFERENCES descomplicai.category(id),
  CONSTRAINT fk_promotion_categories_promotion FOREIGN KEY (promotion_id)
    REFERENCES descomplicai.promotion(id)
);

-- PROMOTION_PRODUCT_ORDER (Corrected FK to composite PK of product_order)
CREATE TABLE IF NOT EXISTS descomplicai.promotion_product_order(
  order_id INTEGER NOT NULL,
  product_id INTEGER NOT NULL,
  promotion_id INTEGER,
  CONSTRAINT pk_promotion_product_order PRIMARY KEY (order_id, product_id), -- Only one promotion per product_order item
  CONSTRAINT fk_promotion_product_order_product_order FOREIGN KEY (order_id, product_id)
    REFERENCES descomplicai.product_order(order_id, product_id),
  CONSTRAINT fk_promotion_product_order_promotion FOREIGN KEY (promotion_id)
    REFERENCES descomplicai.promotion(id)
);

-- INVENTORY_HIST
CREATE TABLE IF NOT EXISTS descomplicai.inventory_hist(
    idlog SERIAL PRIMARY KEY,
    amount_old INTEGER,
    amount_new INTEGER,
    last_update TIMESTAMP DEFAULT now(),
    inventory_id INTEGER,
    CONSTRAINT fk_inventory_hist_inventory FOREIGN KEY (inventory_id)
        REFERENCES descomplicai.inventory(id)
);

-- REVIEW
CREATE TABLE IF NOT EXISTS descomplicai.review(
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    order_id INTEGER NOT NULL,
    rate SMALLINT,
    comment_review VARCHAR(300),
    date_review TIMESTAMP,
    CONSTRAINT fk_review_user FOREIGN KEY (user_id)
        REFERENCES descomplicai.user(id),
    CONSTRAINT fk_review_order FOREIGN KEY (order_id)
        REFERENCES descomplicai.order(id)
);

-- INVENTORY_HIST_STATUS
CREATE TABLE IF NOT EXISTS descomplicai.inventory_hist_status(
    idlog SERIAL PRIMARY KEY,
    status_old VARCHAR(100),
    status_new VARCHAR(100),
    last_update TIMESTAMP DEFAULT now(),
    inventory_id INTEGER,
    CONSTRAINT fk_inventory_hist_status_inventory FOREIGN KEY (inventory_id)
        REFERENCES descomplicai.inventory(id)
);

-- USER_HIST (Removed password_user for security)
CREATE TABLE IF NOT EXISTS descomplicai.user_hist(
  idlog SERIAL PRIMARY KEY,
  user_id INTEGER,
  name_user VARCHAR(100), -- NOT NULL removed, as it might be an update for other fields
  email VARCHAR(100),
  -- password_user VARCHAR(60), -- REMOVED FOR SECURITY
  creation_data TIMESTAMP,
  type_user  VARCHAR(100),
  status VARCHAR(100),
  phone VARCHAR(14),
  date_alter_user TIMESTAMP DEFAULT now(),
  CONSTRAINT fk_user_hist_user FOREIGN KEY (user_id)
      REFERENCES descomplicai.user(id)
);

-- ==============================================
-- TRIGGERS
-- ==============================================

-- LOG INVENTORY_HIST
CREATE OR REPLACE FUNCTION descomplicai.log_inventory_update()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.amount IS DISTINCT FROM OLD.amount THEN
        INSERT INTO descomplicai.inventory_hist (amount_old, amount_new, inventory_id)
        VALUES (OLD.amount, NEW.amount, OLD.id);
    END IF;

    NEW.last_update := now(); -- This is fine for BEFORE trigger

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_inventory_update
BEFORE UPDATE ON descomplicai.inventory
FOR EACH ROW
EXECUTE FUNCTION descomplicai.log_inventory_update();

-- UPDATE INVENTORY_STATUS
CREATE OR REPLACE FUNCTION descomplicai.update_inventory_status()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.amount <= 0 THEN
        NEW.status := 'Esgotado';
    ELSIF NEW.amount < NEW.amount_min THEN
        NEW.status := 'Estoque Baixo';
    ELSE
        NEW.status := 'DisponÃ­vel';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_inventory_status
BEFORE UPDATE OF amount ON descomplicai.inventory
FOR EACH ROW
EXECUTE FUNCTION descomplicai.update_inventory_status();

-- UPDATE PRODUCT_AVAILABILITY
CREATE OR REPLACE FUNCTION descomplicai.update_product_availability()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.amount = 0 THEN
        UPDATE descomplicai.product
        SET availability = FALSE
        WHERE id = NEW.product_id;
    ELSE
        UPDATE descomplicai.product
        SET availability = TRUE
        WHERE id = NEW.product_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_inventory_amount_zero
AFTER UPDATE OF amount ON descomplicai.inventory
FOR EACH ROW
EXECUTE FUNCTION descomplicai.update_product_availability();

-- LOG INVENTORY_HIST_STATUS (Removed NEW.last_update as it's an AFTER trigger)
CREATE OR REPLACE FUNCTION descomplicai.log_inventory_hist_status()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status IS DISTINCT FROM OLD.status THEN
        INSERT INTO descomplicai.inventory_hist_status (status_old, status_new, inventory_id)
        VALUES (OLD.status, NEW.status, OLD.id);
    END IF;
    -- Removed NEW.last_update := now(); as it's an AFTER trigger
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_inventory_hist_status
AFTER UPDATE ON descomplicai.inventory
FOR EACH ROW
EXECUTE FUNCTION descomplicai.log_inventory_hist_status();

-- INSERT ORDER_ADDRESS
CREATE OR REPLACE FUNCTION descomplicai.fn_insert_order_address()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO descomplicai.order_address (
    order_id,
    street,
    type_address,
    cep,
    number_address,
    neighborhood,
    complement,
    reference,
    city,
    uf
  )
  SELECT DISTINCT ON (o.id)
    o.id AS order_id,
    a.street,
    ua.type_address,
    a.cep,
    a.number_address,
    a.neighborhood,
    a.complement,
    a.reference,
    a.city,
    a.uf
  FROM descomplicai."order" AS o
  JOIN descomplicai."user" AS u
    ON u.id = o.user_id
  JOIN descomplicai.user_address AS ua
    ON ua.user_id = u.id
  JOIN descomplicai.address AS a
    ON a.id = ua.address_id
  WHERE o.id = NEW.id
    AND ua.type_address IS NOT NULL
  ORDER BY o.id,
           CASE -- Prioritize delivery address, then billing, then any other
               WHEN ua.type_address = 'entrega' THEN 1
               WHEN ua.type_address = 'cobranca' THEN 2
               ELSE 3
           END,
           a.id DESC -- Fallback for consistent choice if multiple of same type
  ON CONFLICT (order_id) DO NOTHING;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_insert_order_address
AFTER INSERT ON descomplicai."order"
FOR EACH ROW
EXECUTE FUNCTION descomplicai.fn_insert_order_address();

-- UPDATE_ORDER_TOTAL
CREATE OR REPLACE FUNCTION descomplicai.fn_update_order_total()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE descomplicai."order" o
  SET total_value = (
    COALESCE((
      SELECT SUM(po.total_value)
      FROM descomplicai.product_order po
      WHERE po.order_id = o.id
    ), 0) + COALESCE(o.delivery_tax, 0)
  )
  WHERE o.id = COALESCE(NEW.order_id, OLD.order_id); -- Correctly uses NEW/OLD order_id

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_order_total
AFTER INSERT OR UPDATE OR DELETE
ON descomplicai.product_order
FOR EACH ROW
EXECUTE FUNCTION descomplicai.fn_update_order_total();

-- UPDATE PRODUCT ORDER TOTAL (Corrected to use composite PK)
CREATE OR REPLACE FUNCTION descomplicai.fn_update_product_order_total()
RETURNS TRIGGER AS $$
DECLARE
  v_price NUMERIC(10,2);
  v_amount INTEGER;
  v_discount NUMERIC(10,2) := 0;
BEGIN
  -- Fetch product price based on NEW.product_id
  SELECT p.price
  INTO v_price
  FROM descomplicai.product p
  WHERE p.id = NEW.product_id;

  -- Use NEW.amount directly from the current product_order row
  v_amount := NEW.amount;

  -- Fetch discount for the specific product_order item (using composite key)
  SELECT pr.value
  INTO v_discount
  FROM descomplicai.promotion pr
  JOIN descomplicai.promotion_product_order ppo
    ON pr.id = ppo.promotion_id
  WHERE ppo.order_id = NEW.order_id
    AND ppo.product_id = NEW.product_id
  LIMIT 1;

  -- Update total_value for the specific product_order item (using composite key)
  UPDATE descomplicai.product_order
  SET total_value = GREATEST((v_price * v_amount) - COALESCE(v_discount, 0), 0) -- Discount is applied directly, not multiplied by amount again
  WHERE order_id = NEW.order_id AND product_id = NEW.product_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_product_order_total
AFTER INSERT OR UPDATE OF product_id, amount
ON descomplicai.product_order
FOR EACH ROW
EXECUTE FUNCTION descomplicai.fn_update_product_order_total();

-- INSERT PROMOTION FUNCTION (Corrected to use composite PK for promotion_product_order)
CREATE OR REPLACE FUNCTION descomplicai.fn_apply_single_promotion_to_product_order()
RETURNS TRIGGER AS $$
DECLARE
  v_promotion_id INTEGER := NULL;
  v_category_id INTEGER := NULL;
BEGIN
  -- 1. Try to find an active PRODUCT-SPECIFIC promotion for the new product_order item
  SELECT pr.id
  INTO v_promotion_id
  FROM descomplicai.promotion pr
  JOIN descomplicai.promotion_products pp ON pp.promotion_id = pr.id
  WHERE pp.product_id = NEW.product_id
    AND pr.active = TRUE
    AND pr.type_promotion = 'produto'
    AND CURRENT_DATE BETWEEN pr.start_date AND pr.end_date
  ORDER BY pr.priority DESC, pr.id DESC
  LIMIT 1;

  -- 2. If no product-specific promotion is found, try to find an active CATEGORY-SPECIFIC promotion
  IF v_promotion_id IS NULL THEN
    -- Get the category of the product (now from product table directly)
    SELECT p.category_id
    INTO v_category_id
    FROM descomplicai.product p
    WHERE p.id = NEW.product_id;

    IF v_category_id IS NOT NULL THEN
      SELECT pr.id
      INTO v_promotion_id
      FROM descomplicai.promotion pr
      JOIN descomplicai.promotion_categories pc ON pc.promotion_id = pr.id
      WHERE pc.category_id = v_category_id
        AND pr.active = TRUE
        AND pr.type_promotion = 'categoria'
        AND CURRENT_DATE BETWEEN pr.start_date AND pr.end_date
      ORDER BY pr.priority DESC, pr.id DESC
      LIMIT 1;
    END IF;
  END IF;

  -- 3. If a promotion is found (either product or category), insert it into promotion_product_order
  IF v_promotion_id IS NOT NULL THEN
    INSERT INTO descomplicai.promotion_product_order (order_id, product_id, promotion_id)
    VALUES (NEW.order_id, NEW.product_id, v_promotion_id)
    ON CONFLICT (order_id, product_id) DO UPDATE SET promotion_id = EXCLUDED.promotion_id; -- Update if already exists
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_apply_single_promotion_to_product_order
AFTER INSERT
ON descomplicai.product_order
FOR EACH ROW
EXECUTE FUNCTION descomplicai.fn_apply_single_promotion_to_product_order();

-- LOG ORDER_HIST (Corrected order_date and adjusted conditions)
CREATE OR REPLACE FUNCTION descomplicai.log_order_hist()
RETURNS TRIGGER AS $$
BEGIN
    -- Log if any of the specified fields change
    IF NEW.status IS DISTINCT FROM OLD.status OR
       NEW.delivery_tax IS DISTINCT FROM OLD.delivery_tax OR
       NEW.payment_method IS DISTINCT FROM OLD.payment_method OR
       NEW.total_value IS DISTINCT FROM OLD.total_value
    THEN
        INSERT INTO descomplicai.order_hist(
            order_id,
            status,
            delivery_tax,
            payment_method,
            user_id,
            total_value,
            order_date -- Use OLD.order_date as the original order date
        )
        VALUES (
            OLD.id,
            NEW.status,
            NEW.delivery_tax,
            NEW.payment_method,
            OLD.user_id,
            NEW.total_value,
            OLD.order_date
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_order_hist
BEFORE UPDATE ON descomplicai.order
FOR EACH ROW
EXECUTE FUNCTION descomplicai.log_order_hist();

-- LOG USER_HIST (Removed password_user, adjusted NOT NULL for flexibility)
CREATE OR REPLACE FUNCTION descomplicai.log_user_hist()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.name_user IS DISTINCT FROM OLD.name_user OR
       NEW.email IS DISTINCT FROM OLD.email OR
       -- NEW.password_user IS DISTINCT FROM OLD.password_user OR -- REMOVED FOR SECURITY
       NEW.status IS DISTINCT FROM OLD.status OR
       NEW.phone IS DISTINCT FROM OLD.phone
    THEN
        INSERT INTO descomplicai.user_hist(
            user_id,
            name_user,
            email,
            -- password_user, -- REMOVED FOR SECURITY
            creation_data,
            type_user,
            status,
            phone
        )
        VALUES (
            OLD.id,
            NEW.name_user,
            NEW.email,
            -- OLD.password_user, -- REMOVED FOR SECURITY (or NEW.password_user if you did hash it)
            OLD.creation_data,
            OLD.type_user,
            NEW.status,
            NEW.phone
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_user_hist
AFTER INSERT OR UPDATE ON descomplicai.user
FOR EACH ROW
EXECUTE FUNCTION descomplicai.log_user_hist();

-- FUNCTION UPDATE INVENTORY_AMOUNT
CREATE OR REPLACE FUNCTION descomplicai.fn_update_inventory_amount()
RETURNS TRIGGER AS $$
BEGIN
  -- Loop through all product_order items for the current order
  -- This loop is now safe as NEW.id for order is correctly used
  FOR r IN
    SELECT po.product_id, po.amount
    FROM descomplicai.product_order po
    WHERE po.order_id = NEW.id
  LOOP
    IF OLD.status = 'Em Andamento' AND NEW.status = 'Confirmado' THEN
      UPDATE descomplicai.inventory
      SET amount = amount - r.amount
      WHERE product_id = r.product_id;

    ELSIF OLD.status = 'Confirmado' AND NEW.status = 'Em Andamento' THEN
      UPDATE descomplicai.inventory
      SET amount = amount + r.amount
      WHERE product_id = r.product_id;

    ELSIF OLD.status = 'Confirmado' AND NEW.status = 'Cancelado' THEN
      UPDATE descomplicai.inventory
      SET amount = amount + r.amount
      WHERE product_id = r.product_id;
    END IF;
  END LOOP;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_inventory_amount
AFTER UPDATE OF status
ON descomplicai."order"
FOR EACH ROW
EXECUTE FUNCTION descomplicai.fn_update_inventory_amount();
